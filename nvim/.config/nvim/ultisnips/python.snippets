global !p
import os
endglobal

snippet abc "import abc" b
from abc import ABCMeta, abstractmethod

endsnippet

snippet opt "import option" b
from typing import Optional

endsnippet

snippet im; "import from" bA
${1/..*/from /}${1}${1/..*/ /)}import $0
endsnippet

snippet "fn(a){0,1};" "define a function" brA
`!p
if match.group(1):
	snip.rv = "async "`def ${1:fname}($0)${2/..*/ -> /}${2}:
endsnippet

snippet cl; "define a class" bA
class ${1:cname}:
	def __init__(self, ${2:`indent('.') ? 'self' : ''`}):
		$0
endsnippet

snippet abs; "abstractmethod" bA
@abstractmethod

endsnippet

snippet in; "define a interface" bA
class ${1:cname}(metaclass=ABCMeta):
	@abstractmethod
	def ${2:fnname}($0)${3/..*/ -> /}${3}:
endsnippet

snippet op; "Optional[]" wA
Optional[$1]$0
endsnippet

# Loging
snippet try; "try except" bA
try:
	${VISUAL}

except Exception:
	pexcept()
$0
endsnippet

snippet log "log initialization" b
from .logger import * 

log = logger_setup(__name__, "/tmp/`!p snip.rv = os.environ["VIRTUAL_ENV"].split("/")[-1] if "VIRTUAL_ENV" in os.environ else ""`")
endsnippet

snippet deb; "debug" bA
log.debug("${0:message}")
endsnippet

snippet inf; "info" bA
log.info("${0:message}")
endsnippet

snippet warn; "warning" bA
log.warning("${0:message}")
endsnippet

snippet err; "error" bA
log.error("${0:message}")
endsnippet

snippet crit; "critical" bA
log.critical("${0:message}")
endsnippet

# Test
snippet as; "assert some results" bA
assert ${1:variable} == ${0:result}
endsnippet

snippet time "check the elapsed time of a process" b
start = time.perf_counter()
${VISUAL}
end = time.perf_counter()
print("elapsed time:", str(end - start))
$0
endsnippet

# Numpy
snippet arr "import numpy" w 
np.array([${0:1, 2, 3}])
endsnippet

# Langchain
snippet langim; "import langchain" wA 
from langchain.chat_models import ChatOpenAI
from langchain import LLMChain, HuggingFacePipeline
from langchain.prompts.chat import (
	ChatPromptTemplate,
	SystemMessagePromptTemplate,
	HumanMessagePromptTemplate,
)
endsnippet

snippet langagent "initialize langchain agent" w
from langchain.agents.load_tools import get_all_tool_names
from langchain.agents import load_tools, initialize_agent, AgentType
from langchain.agents import ZeroShotAgent, Tool, AgentExecutor
from langchain.memory import ConversationBufferMemory

# Initialize agents
tools = load_tools(["google-serper", "wikipedia", "python_repl"])
agent = initialize_agent(
	tools, llm, AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=True
)
endsnippet


snippet langdoc "Load documents" w
from langchain.document_loaders import ${1:loader}
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.embeddings import OpenAIEmbeddings
from langchain.embeddings import HuggingFaceEmbeddings 
from langchain.vectorstores import Milvus
from langchain.schema import Document

embeddings = HuggingFaceEmbeddings()

def split_and_vectorized(source, embeddings):
	from langchain.schema import Document

	text_splitter = RecursiveCharacterTextSplitter(chunk_size=1024, chunk_overlap=0)

	if all(isinstance(e, Document) for e in source):
		docs = text_splitter.split_documents(source)
	elif isinstance(source, str):
		docs = text_splitter.create_documents([source])
	else:
		raise ValueError("source must be either a string or a list of Document")
	# search = Pinecone(docs, embeddings, index_name="langauto")
	vector_store = Milvus.from_documents(
		docs,
		embedding=embeddings,
		connection_args={
			"host": os.getenv("MILVUS_HOST"),
			"port": os.getenv("MILVUS_PORT"),
		},
		collection_name="$2"
	)

	return vector_store

def load_collection(collection_nam, embeddings):
	vector_store = Milvus(
		embeddings,
		connection_args={
			"host": os.getenv("MILVUS_HOST"),
			"port": os.getenv("MILVUS_PORT"),
		},
		collection_name=collection_name
	)

	return vector_store

from langchain.chains import RetrievalQA
from langchain.agents import Tool

chain = RetrievalQA.from_chain_type(
	llm=llm, chain_type="stuff", retriever=vstore.as_retriever()
)

${3:tool_name}= Tool(
	name="${4:tool_name}",
	func=chain.run,
	description="${5:description}",
	return_direct=True
)
endsnippet
